---
title: "Boundaries Map Intersections"
output: github_document
---
```{r, libs, include=FALSE}
library(pacman)
p_load(tidyverse, sf, RPostgreSQL, rpostgis)
```
This repo describes one method of creating a single data set (`nyc_boundary_intersections.csv`) containing the boundary relationships in BetaNYC's [Boundaries Map](https://boundaries.beta.nyc/?) using R as an interface to a local PostgreSQL database with the PostGIS extension enabled. 

First, establish a connection to the local database by entering your database name, username, and password:
```{r}
con <- dbConnect(dbDriver("PostgreSQL"),
                 dbname = rstudioapi::showPrompt(
                   title = "Database Name", 
                   message = "Database Name", 
                   default =""),
                 host = "localhost",
                 port = 5432,
                 user = rstudioapi::showPrompt(
                   title = "Username", 
                   message = "Username", 
                   default =""),
                 password = rstudioapi::askForPassword("Database password"))
```

Grab `all_bounds.geojson` from the Boundaries Map [Github repo](https://github.com/BetaNYC/nyc-boundaries/tree/main/script), then inspect field names before loading into database:
```{r}
all_bounds <- read_sf("https://raw.githubusercontent.com/BetaNYC/nyc-boundaries/refs/heads/main/script/all_bounds.geojson")

head(all_bounds)
```

Write the local `sf` object to the local database, excluding unnecessary columns:
```{r}
st_write(all_bounds |>
           # Exclude unnecessary columns
           select(!c(`_errors`, path, layer)) |>
           # Rename columns to follow SQL conventions
           rename(namecol = nameCol,
                  namealt = nameAlt),
         dsn = con,
         layer = "all_bounds",
         delete_layer = T,
         row.names = F,
         field.types = c(id = 'text',
                         namecol = 'text',
                         namealt = 'text',
                         geometry = 'geometry')
         )
```

Set SRID of geometry column to EPSG:4326:
```{r}
# When executing a SELECT... query, the query object must be assigned to a variable, 
# used with dbFetch(), then the result set must be cleared using dbClearResult()

q <- dbSendQuery(con,
                 "SELECT UpdateGeometrySRID('all_bounds','geometry',4326);")

dbFetch(q)
dbClearResult(q)
```

Create a spatial index on the geometry column:
```{r}
# Can use dbExecute() to create index
dbExecute(con,
          "CREATE INDEX all_bounds_geom_idx
          ON all_bounds
          USING GIST(geometry);")
```

Add identity column to filter self-intersecting geometries after self join:
```{r}
dbExecute(con,
          "ALTER TABLE all_bounds 
          ADD COLUMN idty INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY;")
```

Get intersecting relationships. The first common table expression `self_join` performs the intersection, then filters self-intersections. `Intersected_areas` computes the overlapping area between the two geometries. `Deduplicated` removes duplicate intersections, i.e. the intersection of `a` with `b` is retained, but not `b` with `a`. The necessary fields are selected from the result and filtered such that the percent of intersecting area is greater than 0.1%. Note that rounding the intersection area percentage to one decimal place in `intersected_areas` and then filtering to results greater than zero effectively filters out intersections less than 0.05%.
```{r}
q <- dbSendQuery(con,
                "WITH self_join AS (
                  SELECT 
                    a.idty AS idty_left,
                    a.id AS id_left,
                    a.namecol AS namecol_left,
                    a.namealt AS namealt_left,
                    a.geometry AS geometry_left,
                    b.idty AS idty_right,
                    b.id as id_right,
                    b.namecol AS namecol_right,
                    b.namealt AS namealt_right,
                    b.geometry AS geometry_right,
                    ST_Intersection(a.geometry, b.geometry) AS intersection_geom
                  FROM all_bounds a
                  JOIN all_bounds b
                  ON ST_Intersects (a.geometry, b.geometry)
                  WHERE a.idty <> b.idty -- Filters self-intersection
                ),
                intersected_areas AS (
                  SELECT
                    idty_left,
                    id_left,
                    namecol_left,
                    namealt_left,
                    geometry_left,
                    idty_right,
                    id_right,
                    namecol_right,
                    namealt_right,
                    geometry_right,
                    intersection_geom,
                    ROUND(
                      100 * (ST_AREA(intersection_geom) / ST_AREA(geometry_left))::numeric, 1
                    ) AS intersection_pct
                  FROM self_join
                ),
                deduplicated AS(
                  SELECT DISTINCT ON (intersection_geom) *
                  FROM intersected_areas
                )
                SELECT
                  id_left,
                  namecol_left,
                  namealt_left,
                  id_right,
                  namecol_right,
                  namealt_right,
                  intersection_pct
                FROM deduplicated
                WHERE intersection_pct > 0
                ORDER BY 
                  id_left, 
                  namecol_left, 
                  id_right, 
                  namecol_right;")

intersections <- dbFetch(q)

dbClearResult(q)
```

Write file to csv
```{r}
write_csv(intersections,
          "nyc_boundary_intersections.csv")
```

