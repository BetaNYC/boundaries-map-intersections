Boundaries Map Intersections
================

This repo describes one method of creating a single data set
(`nyc_boundary_intersections.csv`) containing the boundary relationships
in BetaNYC’s [Boundaries Map](https://boundaries.beta.nyc/?) using R as
an interface to a local PostgreSQL database with the PostGIS extension
enabled.

First, establish a connection to the local database by entering your
database name, username, and password:

``` r
con <- dbConnect(dbDriver("PostgreSQL"),
                 dbname = rstudioapi::showPrompt(
                   title = "Database Name", 
                   message = "Database Name", 
                   default =""),
                 host = "localhost",
                 port = 5432,
                 user = rstudioapi::showPrompt(
                   title = "Username", 
                   message = "Username", 
                   default =""),
                 password = rstudioapi::askForPassword("Database password"))
```

Grab `all_bounds.geojson` from the Boundaries Map [Github
repo](https://github.com/BetaNYC/nyc-boundaries/tree/main/script), then
inspect field names before loading into database:

``` r
all_bounds <- read_sf("https://raw.githubusercontent.com/BetaNYC/nyc-boundaries/refs/heads/main/script/all_bounds.geojson")

head(all_bounds)
```

    ## Simple feature collection with 6 features and 6 fields
    ## Geometry type: MULTIPOLYGON
    ## Dimension:     XY
    ## Bounding box:  xmin: -73.98023 ymin: 40.57675 xmax: -73.70001 ymax: 40.79673
    ## Geodetic CRS:  WGS 84
    ## # A tibble: 6 × 7
    ##   id    nameCol          nameAlt `_errors` layer path                   geometry
    ##   <chr> <chr>            <chr>   <chr>     <chr> <chr>        <MULTIPOLYGON [°]>
    ## 1 pp    63               <NA>    Ring sel… Inva… Poly… (((-73.86327 40.58388, -…
    ## 2 fb    53               <NA>    Ring sel… Inva… Poly… (((-73.74461 40.77895, -…
    ## 3 sd    17               <NA>    Ring sel… Inva… Poly… (((-73.92046 40.66564, -…
    ## 4 bid   Myrtle Avenue D… <NA>    Ring sel… Inva… Poly… (((-73.91103 40.69953, -…
    ## 5 ibz   North Brooklyn   <NA>    Ring sel… Inva… Poly… (((-73.93661 40.70432, -…
    ## 6 cd    404              <NA>    <NA>      Vali… Poly… (((-73.84751 40.73901, -…

Write the local `sf` object to the local database, excluding unnecessary
columns:

``` r
st_write(all_bounds |>
           # Exclude unnecessary columns
           select(!c(`_errors`, path, layer)) |>
           # Rename columns to follow SQL conventions
           rename(namecol = nameCol,
                  namealt = nameAlt),
         dsn = con,
         layer = "all_bounds",
         delete_layer = T,
         row.names = F,
         field.types = c(id = 'text',
                         namecol = 'text',
                         namealt = 'text',
                         geometry = 'geometry')
         )
```

Set SRID of geometry column to EPSG:4326:

``` r
# When executing a SELECT... query, the query object must be assigned to a variable, 
# used with dbFetch(), then the result set must be cleared using dbClearResult()

q <- dbSendQuery(con,
                 "SELECT UpdateGeometrySRID('all_bounds','geometry',4326);")

dbFetch(q)
```

    ##                                updategeometrysrid
    ## 1 public.all_bounds.geometry SRID changed to 4326

``` r
dbClearResult(q)
```

    ## [1] TRUE

Create a spatial index on the geometry column:

``` r
# Can use dbExecute() to create index
dbExecute(con,
          "CREATE INDEX all_bounds_geom_idx
          ON all_bounds
          USING GIST(geometry);")
```

    ## [1] 0

Add identity column to filter self-intersecting geometries after self
join:

``` r
dbExecute(con,
          "ALTER TABLE all_bounds 
          ADD COLUMN idty INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY;")
```

    ## [1] 0

Get intersecting relationships. The first common table expression
`self_join` performs the intersection, then filters self-intersections.
`Intersected_areas` computes the overlapping area between the two
geometries. `Deduplicated` removes duplicate intersections, i.e. the
intersection of `a` with `b` is retained, but not `b` with `a`. The
necessary fields are selected from the result and filtered such that the
percent of intersecting area is greater than 0.1%. Note that rounding
the intersection area percentage to one decimal place in
`intersected_areas` and then filtering to results greater than zero
effectively filters out intersections less than 0.05%.

``` r
q <- dbSendQuery(con,
                "WITH self_join AS (
                  SELECT 
                    a.idty AS idty_left,
                    a.id AS id_left,
                    a.namecol AS namecol_left,
                    a.namealt AS namealt_left,
                    a.geometry AS geometry_left,
                    b.idty AS idty_right,
                    b.id as id_right,
                    b.namecol AS namecol_right,
                    b.namealt AS namealt_right,
                    b.geometry AS geometry_right,
                    ST_Intersection(a.geometry, b.geometry) AS intersection_geom
                  FROM all_bounds a
                  JOIN all_bounds b
                  ON ST_Intersects (a.geometry, b.geometry)
                  WHERE a.idty <> b.idty -- Filters self-intersection
                ),
                intersected_areas AS (
                  SELECT
                    idty_left,
                    id_left,
                    namecol_left,
                    namealt_left,
                    geometry_left,
                    idty_right,
                    id_right,
                    namecol_right,
                    namealt_right,
                    geometry_right,
                    intersection_geom,
                    ROUND(
                      100 * (ST_AREA(intersection_geom) / ST_AREA(geometry_left))::numeric, 1
                    ) AS intersection_pct
                  FROM self_join
                ),
                deduplicated AS(
                  SELECT DISTINCT ON (intersection_geom) *
                  FROM intersected_areas
                )
                SELECT
                  id_left,
                  namecol_left,
                  namealt_left,
                  id_right,
                  namecol_right,
                  namealt_right,
                  intersection_pct
                FROM deduplicated
                WHERE intersection_pct > 0
                ORDER BY 
                  id_left, 
                  namecol_left, 
                  id_right, 
                  namecol_right;")

intersections <- dbFetch(q)

dbClearResult(q)
```

    ## [1] TRUE

Write file to csv

``` r
write_csv(intersections,
          "nyc_boundary_intersections.csv")
```
